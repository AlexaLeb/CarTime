# CarTime

## Доменная модель сервиса прогнозирования спроса
Проект CarTime представляет собой сервис для прогнозирования часового спроса на поездки (ride count) в городах, построенный по микро-сервисной архитектуре и опирающийся на открытые данные и проверенную SARIMAX-модель. На данный момент проект делает прогнозы корректно только по NYC. В основе лежит следующая схема:
## 1. Версионирование модели (DVC)

- Обученная SARIMAX-модель сохраняется в файле `best_sarimax_model.joblib`.
- Этот файл отслеживается с помощью DVC, что позволяет:
  - Откатываться к любой предыдущей версии модели.
  - Гарантировать воспроизводимость экспериментов.

---

## 2. HTTP API (FastAPI)

1. **Клиент** (браузер или сторонний сервис) отправляет POST-запрос на эндпоинт `/model/` с JSON-массивом экзогенных признаков:
   - `timestamp` (ISO-строка)
   - `pickup_location_id`
   - Погодные данные (AWND, PRCP, SNOW, SNWD, TMAX, TMIN, WT01)
2. **FastAPI**:
   - Аутентифицирует пользователя (JWT в cookie или заголовке).
   - Проверяет и обновляет баланс (списывает 50 баллов).
   - Кладёт задачу в очередь RabbitMQ.
   - Немедленно возвращает HTML-ответ с уведомлением об отправке задачи.

---

## 3. Асинхронная обработка (RabbitMQ + Worker)

- **RabbitMQ** хранит очередь `prediction_requests`, разгружая веб-сервер от долгих вычислений.
- **Worker** (`worker.py`):
  1. Старет и один раз загружает модель из `best_sarimax_model.joblib`.
  2. Слушает очередь, получает JSON-запрос.
  3. Преобразует JSON в `pandas.DataFrame`.
  4. Вызывает `predict_from_dataframe`, округляет и форматирует результаты.
  5. Сохраняет прогноз в PostgreSQL (таблица `predictions`, колонка `predicted_values` хранит JSON-массив словарей).
  6. Отправляет RPC-ответ (или подтверждение), чтобы веб-сервер узнал об успешном сохранении.

---

## 4. Хранение результатов (PostgreSQL)

Каждый прогноз сохраняется с полями:
- `user_id` — кто запросил прогноз  
- `requested_at` — время запроса  
- `predicted_values` — список `{ timestamp, ride_count }`  
- `cost` — стоимость операции (50 баллов)  

История доступна через веб-интерфейс.

---

## 5. Веб-интерфейс (Jinja2)

- **Форма ввода**: `<textarea name="exog">` для JSON-массива экзогенных данных.  
- **Пример формата** показывается над формой.  
- **Результат прогноза** выводится сразу после обработки:
  ```text
  21 Jul 2025 00:00 — 10 171 поездок  
  21 Jul 2025 01:00 — 10 658 поездок  
  21 Jul 2025 02:00 — 11 211 поездок  
## 1. Бизнес-анализ (Business Understanding)

**Цели и заинтересованные стороны:**
- **Разработчик:** студенческий проект по итогам обучения.  
- **Основной потребитель:** городские органы управления трафиком или частные урбанистические проекты.  
- **Косвенные бенефициары:** пассажиры такси/каршеринга, которым прогноз поможет сократить время ожидания.

**Ключевая бизнес-цель:**  
Снижение простоев и повышение доступности такси/каршеринга за счёт прогноза спроса и поддержки динамического распределения ресурсов.

**Конкурентная среда:**  
- Крупные игроки (Uber, Lyft, DiDi) имеют свои проприетарные системы прогнозирования и ценообразования.  
- CarTime предлагает открытое, лёгковесное и воспроизводимое решение на основе открытых данных.

---

## 2. Оценка текущей ситуации (Assessing Current Solution)

- **Инфраструктура разработки:** MacBook Air M4, Docker-контейнеры для RabbitMQ и PostgreSQL.  
- **Источники данных (все открытые):**
  - NYC TLC Trip Record Data — исторические поездки такси по районам.  
  - Uber Movement — средняя длительность поездок по районам.  
  - OpenStreetMap — географические границы и дорожная сеть.  
  - NOAA Weather Data — погодные параметры (осадки, температура, ветер).  
  - Данные о массовых мероприятиях и демографии.  
- **Риски:**  
  - Ограниченные вычислительные ресурсы.  
  - Шум и ошибки в данных.  
  - **Mitigation:** простые модели, кросс-валидация, агрегированное представление.

---

## 3. Цели аналитики (Data Mining Goals)

- **Задача:** прогнозирование количества поездок (`ride_count`) по району и времени (почасово).  
- **Метрики качества:**  
  - **R² > 0.7**  
  - **RMSE < 20%** от базового прогноза (константный уровень спроса).

---

## 4. Минимальные требования к функциональности

1. **Прогноз спроса:** количество поездок по районам и времени.  
2. **Агрегация данных** из нескольких источников (трафик, погода, карта, события).  
3. **Визуализация результатов** — график или тепловая карта по времени и районам.  
4. **Простой web-интерфейс** (FastAPI + Jinja2) или экспорт в CSV/XLSX.  
5. **Небольшие ресурсы:** запуск на обычном ноутбуке за < 2 мин.  
6. **Оценка качества:** R² > 0.7, RMSE < 20%.

**Преимущества проекта:**
- Открытость и воспроизводимость (open-source, DVC для моделей).  
- Модульность и гибкость: легко подключать новые источники и менять частоту агрегации.  
- Простое развёртывание: Docker Compose, единая SARIMAX-модель.

### Сущности    
	1.	User    
	•	user_id (PK) — уникальный идентификатор пользователя    
	•	email — логин (уникальный адрес электронной почты)  
	•	password_hash — хеш пароля  
	•	created_at — дата и время создания аккаунта     
	2.	Balance 
	•	balance_id (PK) — уникальный идентификатор записи баланса   
	•	user_id (FK → User.user_id) — ссылка на владельца баланса   
	•	amount — текущая сумма на балансе (decimal) 
	•	updated_at — дата и время последнего изменения баланса  
	3.	Transaction 
	•	tx_id (PK) — уникальный идентификатор транзакции    
	•	user_id (FK → User.user_id) — ссылка на пользователя, которому при надлежит транзакция  
	•	balance_id (FK → Balance.balance_id) — ссылка на баланс пользователя    
	•	tx_type — тип операции: debit (списание) или credit (пополнение)    
	•	amount — сумма операции (decimal)   
	•	timestamp — дата и время транзакции 
	•	description — необязательное текстовое описание операции    
	4.	Prediction  
	•	prediction_id (PK) — уникальный идентификатор прогноза  
	•	user_id (FK → User.user_id) — ссылка на автора прогноза 
	•	requested_at — дата и время запроса прогноза    
	•	region — регион, для которого сделан прогноз    
	•	predicted_value — предсказанное количество поездок  
	•	cost — стоимость этого прогноза (списываемая с баланса) 

⸻

### Связи (отношения)   
	•	User ↔ Balance (1:1) аждый пользователь имеет ровно один текущий баланс.        
	•	User → Prediction (1:М) Один пользователь может делать множество прогнозов. 
	•	User → Transaction (1:М) Один пользователь может совершать множество операций по своему балансу. 
	•	Balance → Transaction (1:М) Каждому балансу соответствует множество транзакций (списаний и пополнений). 
	•	Prediction → Transaction (логика приложения) При создании прогноза в системе создаётся транзакция типа debit на сумму cost. 

## 🚀 Быстрый старт

### 1. Клонируйте репозиторий

```bash
git clone <URL вашего репозитория>
cd <название_папки>
```

### 2. Переменные окружения

Создайте файл `.env` в папке `app/` со следующим содержимым:

```
SECRET_KEY=ваш_секретный_ключ  
COOKIE_NAME=access_token  
DATABASE_URL=postgresql://user:pass@database/db  
RABBITMQ_HOST=rabbitmq  
```

### 3. Запуск через Docker Compose

```bash
docker-compose up -d --build
```

Будут подняты сервисы:
- `app` (FastAPI и весь остальной бэкенд)
- `web` (nginx)
- `rabbitmq` (менеджер очереди)
- `database` (PostgreSQL)
- `worker` (Обработчик сообщений из очереди)

### 4. Открытие в браузере

- Документация Swagger UI: [http://localhost/docs](http://localhost/docs)  
- Веб‑интерфейс: [http://localhost](http://localhost)
- Дашборд для мониторинга: [https://www.apianalytics.dev](https://www.apianalytics.dev)

---

## 🎯 Основные возможности

- Регистрация и аутентификация пользователей (JWT + куки)
- Управление балансом (депозиты, списания)
- Отправка задач в RabbitMQ и асинхронная обработка воркерами
- Эмитация работы ML
- Просмотр истории предсказаний
- Интерактивная документация REST API (Swagger)
- Веб‑интерфейс с шаблонами Jinja2

---

## 🧪 Тестирование

### Запуск тестов:

```bash
pytest -q --disable-warnings --maxfail=1
```

Если вы используете Docker:

```bash
docker-compose run --rm app pytest -q --disable-warnings --maxfail=1
```

---

## 📝 Документация API

После запуска проекта перейдите по адресу:

👉 [http://localhost/docs](http://localhost/docs)

---

## 🚀 Деплой

- Соберите контейнеры:

```bash
docker-compose up -d --build
```

- Настройте прокси/домен в `nginx/nginx.conf`
- Откройте порты 80/443 и при необходимости настройте SSL

---

## 📄 Лицензия

MIT © *Лебедев Александр Витальевич*